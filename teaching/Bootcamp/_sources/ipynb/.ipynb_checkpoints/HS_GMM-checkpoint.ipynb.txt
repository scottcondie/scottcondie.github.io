{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Estimating the parameters of a Lucas Tree: Hansen and Singleton (1982)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import pandas_datareader.data as web\n",
    "import matplotlib.pyplot as plt\n",
    "import datetime\n",
    "from scipy.optimize import fsolve\n",
    "from scipy.optimize import broyden1\n",
    "from scipy.optimize import minimize\n",
    "from pprint import pprint\n",
    "%matplotlib inline"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>rpce</th>\n",
       "      <th>w5000</th>\n",
       "      <th>tb</th>\n",
       "      <th>gdef</th>\n",
       "      <th>inf</th>\n",
       "      <th>w5000_d</th>\n",
       "      <th>R</th>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>DATE</th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>1971-01-01</th>\n",
       "      <td>2968.902</td>\n",
       "      <td>1.00</td>\n",
       "      <td>1.0444</td>\n",
       "      <td>23.536</td>\n",
       "      <td>1.015270</td>\n",
       "      <td>0.984959</td>\n",
       "      <td>1.122320</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1971-04-01</th>\n",
       "      <td>2996.124</td>\n",
       "      <td>1.12</td>\n",
       "      <td>1.0386</td>\n",
       "      <td>23.846</td>\n",
       "      <td>1.013171</td>\n",
       "      <td>1.105440</td>\n",
       "      <td>1.011948</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1971-07-01</th>\n",
       "      <td>3020.036</td>\n",
       "      <td>1.13</td>\n",
       "      <td>1.0540</td>\n",
       "      <td>24.088</td>\n",
       "      <td>1.010148</td>\n",
       "      <td>1.118647</td>\n",
       "      <td>0.992965</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1971-10-01</th>\n",
       "      <td>3070.230</td>\n",
       "      <td>1.12</td>\n",
       "      <td>1.0446</td>\n",
       "      <td>24.288</td>\n",
       "      <td>1.008303</td>\n",
       "      <td>1.110777</td>\n",
       "      <td>1.046124</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1972-01-01</th>\n",
       "      <td>3110.801</td>\n",
       "      <td>1.18</td>\n",
       "      <td>1.0338</td>\n",
       "      <td>24.664</td>\n",
       "      <td>1.015481</td>\n",
       "      <td>1.162011</td>\n",
       "      <td>1.077729</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1972-04-01</th>\n",
       "      <td>3170.159</td>\n",
       "      <td>1.26</td>\n",
       "      <td>1.0371</td>\n",
       "      <td>24.815</td>\n",
       "      <td>1.006122</td>\n",
       "      <td>1.252333</td>\n",
       "      <td>1.004674</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1972-07-01</th>\n",
       "      <td>3219.095</td>\n",
       "      <td>1.27</td>\n",
       "      <td>1.0398</td>\n",
       "      <td>25.048</td>\n",
       "      <td>1.009389</td>\n",
       "      <td>1.258186</td>\n",
       "      <td>1.020280</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1972-10-01</th>\n",
       "      <td>3294.606</td>\n",
       "      <td>1.30</td>\n",
       "      <td>1.0474</td>\n",
       "      <td>25.366</td>\n",
       "      <td>1.012696</td>\n",
       "      <td>1.283703</td>\n",
       "      <td>1.070357</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1973-01-01</th>\n",
       "      <td>3354.764</td>\n",
       "      <td>1.39</td>\n",
       "      <td>1.0541</td>\n",
       "      <td>25.661</td>\n",
       "      <td>1.011630</td>\n",
       "      <td>1.374020</td>\n",
       "      <td>0.917591</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1973-04-01</th>\n",
       "      <td>3353.357</td>\n",
       "      <td>1.28</td>\n",
       "      <td>1.0626</td>\n",
       "      <td>26.052</td>\n",
       "      <td>1.015237</td>\n",
       "      <td>1.260789</td>\n",
       "      <td>0.918401</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "                rpce  w5000      tb    gdef       inf   w5000_d         R\n",
       "DATE                                                                     \n",
       "1971-01-01  2968.902   1.00  1.0444  23.536  1.015270  0.984959  1.122320\n",
       "1971-04-01  2996.124   1.12  1.0386  23.846  1.013171  1.105440  1.011948\n",
       "1971-07-01  3020.036   1.13  1.0540  24.088  1.010148  1.118647  0.992965\n",
       "1971-10-01  3070.230   1.12  1.0446  24.288  1.008303  1.110777  1.046124\n",
       "1972-01-01  3110.801   1.18  1.0338  24.664  1.015481  1.162011  1.077729\n",
       "1972-04-01  3170.159   1.26  1.0371  24.815  1.006122  1.252333  1.004674\n",
       "1972-07-01  3219.095   1.27  1.0398  25.048  1.009389  1.258186  1.020280\n",
       "1972-10-01  3294.606   1.30  1.0474  25.366  1.012696  1.283703  1.070357\n",
       "1973-01-01  3354.764   1.39  1.0541  25.661  1.011630  1.374020  0.917591\n",
       "1973-04-01  3353.357   1.28  1.0626  26.052  1.015237  1.260789  0.918401"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def convert_to_daily_with_ffill(df):\n",
    "    '''convert_to_daily_with_ffill\n",
    "    \n",
    "    This method converts a dataframe to have a daily index and forward fills all of the missing days.  Useful for converting (for example) stock market data to quarterly data when the quarterly return is wanted.\n",
    "    \n",
    "    :param df: a pandas.DataFrame to be converted\n",
    "    :returns: a pandas.DataFrame that has been converted\n",
    "    '''\n",
    "    \n",
    "    new_idx = pd.date_range('01-01-1950', '07-01-2018')\n",
    "    df = df.reindex(new_idx)\n",
    "    df = df.fillna(method=\"ffill\")\n",
    "    return df\n",
    "    \n",
    "\n",
    "\n",
    "\n",
    "start = datetime.datetime(1950, 1,1)\n",
    "end = datetime.datetime(2018, 7, 1)\n",
    "rpce = web.DataReader('PCECC96', 'fred', start, end)\n",
    "w5000 = web.DataReader('WILL5000INDFC', 'fred', start, end)\n",
    "w5000 = convert_to_daily_with_ffill(w5000)\n",
    "gdef = web.DataReader('GDPDEF', 'fred', start, end)\n",
    "tb = web.DataReader('TB3MS', 'fred', start, end)\n",
    "\n",
    "df = pd.DataFrame(columns=['rpce', 'w5000', 'tb', 'gdef'], index = rpce.index)\n",
    "df['rpce'] = rpce\n",
    "df['w5000'] = w5000\n",
    "df['gdef'] = gdef\n",
    "df['inf'] = df['gdef']/df['gdef'].shift(1)\n",
    "df['w5000_d'] = df['w5000']/df['inf']      # Deflated asset price returns\n",
    "df['R'] = df['w5000_d'].shift(-1)/df['w5000_d']   # Returns to asset prices\n",
    "df['tb'] = tb/100. + 1    # Convert to percentage and make a gross return \n",
    "df  = df.dropna(axis=0)   # Drop NaNs\n",
    "df.head(10)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "      fun: 3.1866964156783745e-05\n",
      " hess_inv: array([[993634.27128949]])\n",
      "      jac: array([4.54747351e-13])\n",
      "  message: 'Optimization terminated successfully.'\n",
      "     nfev: 57\n",
      "      nit: 11\n",
      "     njev: 19\n",
      "   status: 0\n",
      "  success: True\n",
      "        x: array([3.76150208])\n"
     ]
    }
   ],
   "source": [
    "class GMMEstimator_q1(object):\n",
    "    \"\"\"A GMM Estimator for question 1\"\"\"\n",
    "    def __init__(self, df):\n",
    "        self.df = df\n",
    "        self.beta = 0.99   # Since we are not changing this, \n",
    "                           # I make it an instance property from the start.\n",
    "        \n",
    "    def calculate_m(self, gamma):\n",
    "        '''Define the SDF given values for beta and gamma'''\n",
    "        self.df['m'] = self.beta*(self.df['rpce'].shift(-1)/self.df['rpce'])**(-gamma)\n",
    "        #self.df = self.df.dropna(axis=0).copy()\n",
    "        \n",
    "    def objective(self,gamma):\n",
    "        '''The objective to be minimized.'''\n",
    "        self.calculate_m(gamma)     # Calculate the SDF given gamma\n",
    "        df = self.df.copy().dropna(axis=0)\n",
    "        l = df.shape[0]\n",
    "        df['ip'] = (1/l)*(df['m']*df['R'] - 1)\n",
    "        return np.dot(df['ip'].values, df['ip'].values)\n",
    "        \n",
    "    def estimate(self, init):\n",
    "        '''Estimate values for beta and gamma'''\n",
    "        s = minimize(self.objective, init, tol=1e-10 )\n",
    "        print(s)\n",
    "        \n",
    "        \n",
    "e = GMMEstimator_q1(df)\n",
    "e.estimate(100.0)     \n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<matplotlib.figure.Figure at 0x1e41000e518>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'fun': 0.33268058450798116,\n",
      " 'hess_inv': array([[25.47909069]]),\n",
      " 'jac': array([-1.86264515e-08]),\n",
      " 'message': 'Optimization terminated successfully.',\n",
      " 'nfev': 18,\n",
      " 'nit': 4,\n",
      " 'njev': 6,\n",
      " 'status': 0,\n",
      " 'success': True,\n",
      " 'x': array([2.7733041])}\n"
     ]
    }
   ],
   "source": [
    "class GMMEstimator_q3(object):\n",
    "    def __init__(self, df):\n",
    "        self.df = df\n",
    "        self.beta = 0.99   # Since we are not changing this, I make it an instance property from the start.\n",
    "        \n",
    "    def calculate_m(self, gamma):\n",
    "        '''Define the SDF given values for beta and gamma'''\n",
    "        self.df['m'] = self.beta*(self.df['rpce'].shift(-1)/self.df['rpce'])**(-gamma)\n",
    "        \n",
    "    def objective(self,gamma):\n",
    "        self.calculate_m(gamma)\n",
    "        #print(self.df)\n",
    "        #cov = self.df[['m', 'R']].cov()['R']['m']\n",
    "        #ER = self.df['R'].mean()\n",
    "        #Em = self.df['m'].mean()\n",
    "        self.df['inv_m'] = 1/self.df['m']\n",
    "        self.df['diff'] = (self.df['tb'] - self.df['inv_m'])**2\n",
    "        new_df = df.dropna(axis=0)\n",
    "        ob = new_df['diff'].values\n",
    "        #cov = df[['m', 'R']].cov()[\"R\"]['m']\n",
    "        #ER = df['R'].mean()\n",
    "        #Em = df['m'].mean()\n",
    "        return np.sum(ob)\n",
    "        \n",
    "    def estimate(self, init):\n",
    "        '''Estimate values for beta and gamma'''\n",
    "        #s, info, ier, msg = fsolve(self.objective, init, full_output=True)\n",
    "        s = minimize(self.objective, init)\n",
    "        pprint(s)\n",
    "        \n",
    "    def plot(self, min_value, max_value):\n",
    "        ar = np.linspace(min_value, max_value, 100)\n",
    "        out = [ self.objective(aa) for aa in ar]\n",
    "        plt.plot(ar, out)\n",
    "        plt.show()\n",
    "        \n",
    "e = GMMEstimator_q3(df)\n",
    "e.plot(0.1, 5.0)\n",
    "e.estimate(2.5)\n",
    "        \n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'fun': 123.00641288916736,\n",
      " 'hess_inv': array([[ 0.00035324, -0.00069736],\n",
      "       [-0.00069736,  0.00324237]]),\n",
      " 'jac': array([-2.47955322e-05,  0.00000000e+00]),\n",
      " 'message': 'Desired error not necessarily achieved due to precision loss.',\n",
      " 'nfev': 85,\n",
      " 'nit': 14,\n",
      " 'njev': 21,\n",
      " 'status': 2,\n",
      " 'success': False,\n",
      " 'x': array([0.70945192, 0.70185419])}\n",
      "(50, 20) (50, 20)\n"
     ]
    }
   ],
   "source": [
    "class GMMEstimator_q4(object):\n",
    "    def __init__(self, df):\n",
    "        self.df = df\n",
    "        \n",
    "    def calculate_m(self, params):\n",
    "        '''Define the SDF given values for beta and gamma'''\n",
    "        beta, gamma = params\n",
    "        self.df['m'] = beta*(self.df['rpce'].shift(-1)/self.df['rpce'])**(-gamma)\n",
    "    \n",
    "    \n",
    "    def objective(self,params):\n",
    "        '''The function to be minimized.'''\n",
    "        self.calculate_m(params)\n",
    "        \n",
    "        #print(self.df)\n",
    "        #cov = self.df[['m', 'R']].cov()['R']['m']\n",
    "        #ER = self.df['R'].mean()\n",
    "        #Em = self.df['m'].mean()\n",
    "        self.df['inv_m'] = 1/self.df['m']\n",
    "        self.df['diff'] = (self.df['tb'] - self.df['inv_m'])**2\n",
    "        new_df = self.df.dropna(axis=0)\n",
    "        ob = new_df['diff'].values\n",
    "        ob1 = np.sum(ob)\n",
    "        l = new_df.shape[0]\n",
    "        df = new_df.dropna(axis=0).copy()\n",
    "        df['ip'] = (1/l)*(df['m'].dot(df['R']) - 1)\n",
    "        ob2 = np.dot(df['ip'].values, df['ip'].values)\n",
    "        \n",
    "        \n",
    "        #cov = df[['m', 'R']].cov()[\"R\"]['m']\n",
    "        #ER = df['R'].mean()\n",
    "        #Em = df['m'].mean()\n",
    "        return ob1 + ob2\n",
    "        \n",
    "    def estimate(self, init):\n",
    "        '''Estimate values for beta and gamma'''\n",
    "        #s, info, ier, msg = fsolve(self.objective, init, full_output=True)\n",
    "        s = minimize(self.objective, init, tol=1e-8)\n",
    "        pprint(s)\n",
    "        \n",
    "    def plot(self, min_value, max_value):\n",
    "        ar = np.linspace(min_value, max_value, 100)\n",
    "        out = [ self.objective(aa) for aa in ar]\n",
    "        plt.plot(ar, out)\n",
    "        plt.show()\n",
    "        \n",
    "e = GMMEstimator_q4(df)\n",
    "e.estimate([0.7, 50.0])\n",
    "\n",
    "\n",
    "b = np.linspace(0.01, 1.0, 20)\n",
    "g = np.linspace(0.01, 20.0, 50)\n",
    "bg = np.array\n",
    "grid = np.meshgrid(b,g)\n",
    "print(grid[0].shape, grid[1].shape)\n",
    "params = []\n",
    "idx = []\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
